<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport"
	      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>IndexedDB API</title>

	<style>
		fieldset {
			max-width: 500px;
			margin-inline: auto;
		}

		legend:has(:nth-child(2)) {
			display: inline-flex;
			width: 100%;
			justify-content: space-between;
			position: relative;
		}

		legend > *:first-child {
			padding: 0;
			margin: 0;
			display: inline-flex;
			width: 100%;
			align-items: center;
		}

		legend > *:first-child::after {
			content: "";
			display: inline-block;
			border-bottom: 2px solid gray;
			flex: 1
		}

		form {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}

		form > label {
			display: inline-flex;
		}

		label > *:first-child {
			min-width: 50px;
		}

		#preview-attach-file, #preview-video {
			display: inline-block;
			width: 100px;
			height: 100px;
			border: 1px dashed;
			border-radius: 4px;
		}

		#content {
			display: flex;
			gap: 4px;
			flex-wrap: wrap;
		}

		#settings {
			background: unset;
			border: none;
			font-size: 30px;
			color: gray;
			border-radius: 50%;
			aspect-ratio: 1;
			padding: 8px;
			line-height: 0;
			cursor: pointer;
		}

		#settings:hover {
			background: rgba(128, 128, 128, 0.1);
		}

		#settings:active {
			background: rgba(128, 128, 128, 0.5);
			color: white;
		}

		#settings-popover {
			position: absolute;
			background: #fff;
			border: 1px solid;
			border-radius: 4px;
			right: 0;
			top: 100%;
			padding: 4px 0;
			display: inline-flex;
			flex-direction: column;
			margin: 0;
			color: gray
		}

		#settings-popover > li::marker {
			content: "";
		}

		#settings-popover > li {
			padding-block: 4px;
			padding-inline: 10px;
			cursor: pointer;
			display: inline-flex;
			gap: 10px;
			justify-content: space-between;
			font-family: Arial, serif;
			font-size: 14px;
		}

		#settings-popover > li:hover {
			background: rgba(128, 128, 128, 0.1);
		}

		#settings-popover > li:active {
			background: rgba(128, 128, 128, 0.5);
			color: #ffffff;
		}

		dialog {
			text-align: center;
		}
	</style>
</head>
<body>
<fieldset>
	<legend>
		<p>Upload File</p>
		<button id="settings">⚙</button>
		<ul id="settings-popover" style="visibility: hidden">
			<li id="clear">Clear <span>×</span></li>
			<li id="reload">Reload <span>↺</span></li>
		</ul>
	</legend>
	<form>
		<label for="attach-file"><span>&nbsp;</span><input type="file" id="attach-file" required/></label>
		<input value="" name="file" hidden id="file"/>
		<label>
			<span></span>
			<div>
				<template shadowrootmode="open">
					<slot name="file"></slot>
				</template>
				<object id="preview-attach-file" slot="file"></object>
				<video id="preview-video"></video>
			</div>

		</label>
		<label for="title"><span>Title: </span><input id="title" name="title" required/></label>
		<input type="submit" value="Submit"/>
	</form>
</fieldset>
<fieldset>
	<legend>Search</legend>
	<input id="search" autocomplete="off"/>
</fieldset>
<fieldset id="preview">
	<legend>Preview</legend>
	<template id="preview-template">
		<div class="wrap">
			<slot name="file" class="preview-file">File</slot>
			<slot name="label" class="file-name">Label</slot>
			<div id="popover">
				<button id="open">Open New Tab</button>
				<button id="delete">Delete</button>
				<button id="edit">Edit</button>
				<a href="#" id="download" download>Download</a>
			</div>
		</div>
		<style>
			.wrap {
				width: fit-content;
				position: relative;
				cursor: pointer;
			}

			#popover {
				position: absolute;
				border: 1px solid;
				background: #fff;
				display: flex;
				flex-direction: column;
				min-width: 100px;
				width: max-content;
				border-radius: 2px;
				z-index: 1;
				text-align: center;
			}

			button {
				background: unset;
				margin: 0;
				padding: 10px;
				text-align: center;
				border: none;
				cursor: pointer;
			}

			button:hover {
				background: rgba(211, 211, 211, 0.38);
			}

			button:active {
				background: lightgray;
			}

			.preview-file {
				border: 1px solid;
				min-width: 50px;
				height: fit-content;
				display: flex;
				border-radius: 4px;
				justify-content: center;
				align-items: center;
			}

			::slotted(:not(video)) {
				pointer-events: none;
			}

			::slotted(p) {
				padding: 0;
				margin: 0;
			}

			.file-name {
				font-weight: 700;
				font-size: 14px;
				text-align: center;
			}
		</style>
	</template>
	<div id="content">
		<template shadowrootmode="open">
			<slot name="content">Loading...</slot>
		</template>
	</div>
	<dialog>
		<p id="warning-clear">All Data Clear, Cannot Undo!!</p>
		<button id="warning-confirm">OK</button>
		<button id="warning-cancel">Cancel</button>
	</dialog>
</fieldset>

<!-- Elements -->
<script>
	const attachFile = document.getElementById('attach-file');
	const fileUrl = document.getElementById('file');
	const previewObject = document.getElementById('preview-attach-file');
	const previewVideo = document.getElementById('preview-video');
	const form = document.querySelector('form');
	const template = document.getElementById('preview-template');
	const content = document.getElementById('content');
	const search = document.getElementById('search');
	const dialog = document.querySelector('dialog');
	const dialogConfirm = dialog.querySelector('#warning-confirm');
	const dialogCancel = dialog.querySelector('#warning-cancel');
</script>

<!-- Broadcast Channel API-->
<script>
	const broadcast = new BroadcastChannel('channel');
</script>
<!-- Custom Element - File Preview -->
<script>
	class CustomPreview extends HTMLElement {
		constructor () {
			super();
			const shadow = this.attachShadow({ mode: 'open' });
			shadow.appendChild(template.content.cloneNode(true));
		}

		static observedAttributes = ['value'];

		set value (val) {
			this.setAttribute('value', val);
		}

		get value () {
			return this.getAttribute('value');
		}

		connectedCallback () {
			const popover = this.shadowRoot.getElementById('popover');
			const deleteBtn = this.shadowRoot.getElementById('delete');
			const editBtn = this.shadowRoot.getElementById('edit');
			const openBtn = this.shadowRoot.getElementById('open');
			const downloadBtn = this.shadowRoot.getElementById('download');
			downloadBtn.download = this.title;
			popover.style.visibility = 'hidden';

			this.shadowRoot.addEventListener('contextmenu', e => {
				e.preventDefault();
				const popover = this.shadowRoot.getElementById('popover');
				popover.style.top = `${e.offsetY}px`;
				popover.style.left = `${e.offsetX}px`;
				popover.style.removeProperty('visibility');
			}, { capture: true });

			document.addEventListener('click', () => (popover.style.visibility = 'hidden'));
			document.addEventListener('auxclick', (e) => {
				if (!this.contains(e.target)) {
					popover.style.visibility = 'hidden';
				}

			});
			deleteBtn.addEventListener('click', () => {
				deleteData(this.value);
				handleDisplayPreview();
			});
			editBtn.addEventListener('click', () => {
			});

			openBtn.addEventListener('click', async () => {
				const url = await fetch(this.url).then(res => res.blob()).then(blob => URL.createObjectURL(blob));
				window.open(url, '_blank');
				URL.revokeObjectURL(url);
			});
			fetch(this.url)
				.then(res => res.blob())
				.then(blob => URL.createObjectURL(blob))
				.then(url => downloadBtn.href = url);
		}
	}

	customElements.define('custom-preview', CustomPreview);
</script>

<!-- Submit Form-->
<script>
	attachFile.onchange = e => {
		const [file] = e.target.files;
		const isVideo = file.type.includes('video');

		const reader = new FileReader();
		reader.readAsDataURL(file);

		reader.onload = evt => {
			const url = evt.target.result;
			fileUrl.value = url;

			if (!isVideo) {
				previewObject.data = url;
				previewObject.slot = 'file';
				previewVideo.slot = '';
			} else {
				previewVideo.src = URL.createObjectURL(file);
				previewObject.slot = '';
				previewVideo.slot = 'file';
				previewVideo.controls = true;
				previewVideo.autoplay = true;
			}
		};
	};

	form.onsubmit = e => {
		e.preventDefault();
		const formData = new FormData(e.target);
		const values = Object.fromEntries(formData.entries());
		addData(values);
		handleDisplayPreview();
		form.reset();
		attachFile.focus();
		previewObject.data = '';
	};
</script>

<!-- IndexDB API -->
<script>
	const req = indexedDB.open('cat', 1);
	const FACTORY_NAME = 'cat';
	const STORE_NAME = 'cat';

	req.onupgradeneeded = e => {
		const store = e.currentTarget.result.createObjectStore(FACTORY_NAME, {
			keyPath: 'id',
			autoIncrement: true
		});

		store.createIndex('file', 'file', { unique: false });
		store.createIndex('title', 'title', { unique: false });
	};

	const getStore = (mode = 'readwrite') => {
		const req = indexedDB.open('cat', 1);

		return new Promise(resolve => {
			req.onsuccess = e => {
				resolve(e.currentTarget.result.transaction(STORE_NAME, mode).objectStore(STORE_NAME));
			};
		});

	};

	const addData = async (value) => {
		const store = await getStore();
		store.add(value);
		broadcast.postMessage('ADD');
	};

	const getAll = async () => {
		const store = await getStore('readonly');
		const data = store.getAll();

		return new Promise(resolve => {
			data.onsuccess = e => {
				const result = e.target.result.filter(({ title }) => new RegExp(`${search.value.trim().toLowerCase()}.*`, 'g').test(title.toLowerCase()));
				resolve(result);
				broadcast.postMessage('GET ALL');
			};
		});
	};

	const getData = async (key, value) => {
		const store = await getStore();
		const req = store.index(key);
		const record = req.get(value);
		return new Promise((resolve, reject) => {
			record.onsuccess = e => {
				if (!e.target.result) {
					reject('Not Found');
					return;
				}
				resolve(e.target.result);
			};

			record.onerror = () => reject('Error IndexedDB');
		});
	};

	const deleteData = async (key) => {
		const store = await getStore();
		store.delete(Number(key));
		broadcast.postMessage('DELETE');
	};

	const clearDB = async () => {
		const store = await getStore();
		store.clear();
		broadcast.postMessage('CLEAR');
	};
</script>

<!-- Display Preview -->
<script>
	const handleDisplayPreview = async () => {
		const res = await getAll();
		const data = await Promise.all(res.map(async ({
			file,
			...item
		}) => {
			const blob = await fetch(file).then(res => res.blob()).then(blob => URL.createObjectURL(blob));
			return {
				...item,
				file: blob,
				isVideo: file.includes('video')
			};
		}));

		const previews = await Promise.all(data.map(async ({
			file,
			title,
			id,
			isVideo
		}) => {
			const customPreview = document.createElement('custom-preview');
			const object = document.createElement('object');
			const video = document.createElement('video');
			const p = document.createElement('p');
			customPreview.value = id;
			customPreview.url = file;
			customPreview.title = title;
			object.data = file;
			video.height = 200;
			video.src = file;
			video.autoplay = true;
			video.controls = true;
			p.slot = 'label';
			p.innerHTML = title;

			if (isVideo) {
				video.slot = 'file';
			} else {
				object.slot = 'file';
			}
			customPreview.append(object, p, video);

			customPreview.slot = 'content';
			return customPreview;
		}));
		content.replaceChildren(...previews);
	};

	broadcast.addEventListener('message', () => handleDisplayPreview());
	handleDisplayPreview();
</script>
<!-- Settings -->
<script>
	const settings = document.getElementById('settings');
	const settingsPopover = document.getElementById('settings-popover');
	const clearBtn = document.getElementById('clear');
	const reloadBtn = document.getElementById('reload');

	clearBtn.onclick = () => {
		dialog.showModal();
		dialogConfirm.onclick = () => {
			clearDB();
			handleDisplayPreview();
			dialog.close();
		};
		dialogCancel.onclick = () => dialog.close();
	};

	reloadBtn.onclick = () => broadcast.postMessage('RELOAD');

	settings.onclick = () => {
		!settingsPopover.style.visibility ?
			settingsPopover.style.setProperty('visibility', 'hidden')
			: settingsPopover.style.removeProperty('visibility');
	};
</script>

<!-- Search -->
<script>
	search.onchange = () => handleDisplayPreview();
</script>
</body>
</html>
